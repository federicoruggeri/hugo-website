<!doctype html>
<!--
  Material Design Lite
  Copyright 2015 Google Inc. All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="A front-end template that helps you build fast, modern mobile web apps.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <title>Project</title>

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="images/android-desktop.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Project">
    <link rel="apple-touch-icon-precomposed" href="images/ios-desktop.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="shortcut icon" href="images/favicon.png">

    <!-- SEO: If your mobile URL is different from the desktop URL, add a canonical link to the desktop page https://developers.google.com/webmasters/smartphone-sites/feature-phones -->
    <!--
    <link rel="canonical" href="http://www.example.com/">
    -->

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.blue_grey-deep_orange.min.css" />
    <link rel="stylesheet" href="styles.css">
    <style>

    #next {
      position: fixed;
      display: block;
      right: 0;
      bottom: 0;
      margin-right: 20px;
      margin-bottom: 20px;
      z-index: 900;
    }

    #prev {
      position: fixed;
      display: block;
      left: 0;
      bottom: 0;
      margin-left: 20px;
      margin-bottom: 20px;
      z-index: 900;
    }

    .content-card-vision {
      background: #EEEEEE;
    }

    .content-card-goal {
      background: #EEEEEE;
    }

    .content-card {
      background: #EEEEEE;
    }

    .noline{
      text-decoration: none;
    }

    .mdl-card__media > img {
      max-width: 100%;
      display:block;
      margin-left:auto;
      margin-right:auto;
    }
    
    </style>
  </head>

  <body class="mdl-demo mdl-color--grey-100 mdl-color-text--grey-700 mdl-base">
    
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
      
      <header class="mdl-layout__header mdl-layout__header--scroll">
        <div class="mdl-layout__header-row">

          <span class="mdl-layout-title"> &amp; Project</span>
          <div class="mdl-layout-spacer"></div>
        </div>

        <div class="mdl-layout__tab-bar mdl-js-ripple-effect">
          <a href="index.html" class="mdl-layout__tab">Home</a>
          <a href="overview.html" class="mdl-layout__tab">Overview</a>
          <a href="analysis.html" class="mdl-layout__tab">Analysis</a>
          <a href="project.html" class="mdl-layout__tab is-active">Project</a>
          <a href="install guide.html" class="mdl-layout__tab">Install Guide</a>
          <a href="examples.html" class="mdl-layout__tab">Examples</a>
        </div>
      </header>

      <div class="mdl-layout__drawer">
          <span class="mdl-layout-title">Contents</span>
          <nav class="mdl-navigation">
            <a class="mdl-navigation__link" href="project.html#choices">Implementation Choices</a>
            <a class="mdl-navigation__link" href="project.html#structure">Structure</a>
            <a class="mdl-navigation__link" href="project.html#net">Net package</a>
            <a class="mdl-navigation__link" href="project.html#actor">Actor package</a>
            <a class="mdl-navigation__link" href="project.html#configuration">Configuration package</a>
            <a class="mdl-navigation__link" href="project.html#utility">Utility package</a>
            <a class="mdl-navigation__link" href="project.html#interaction">Interaction</a>
            <a class="mdl-navigation__link" href="project.html#events">C# Events</a>
            <a class="mdl-navigation__link" href="project.html#mqtt">MQTT</a>
            <a class="mdl-navigation__link" href="project.html#unityconnector">Unity Actor Connector</a>    
          </nav>
      </div>

      <main class="mdl-layout__content">

        <div class="mdl-layout__tab-panel is-active">

          <!--CHOICES-->
          <section class="section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp" id="choices">
            <div class="mdl-card mdl-cell mdl-cell--12-col content-card-vision">
              <div class="mdl-card__supporting-text">
              <h4> Implementation Choices </h4>
                In this section we introduce and explain the major implementation choices that have been taken, with the aim to view and analyze step by step
                the project evolution in its entirety by taking always into account what has been said in the <a class="noline" href="analysis.html"> Analysis </a> section.

              <h5> Define the model </h5>
              First of all, we have to determine each individual macro action that affects the data stream in both directions. In other terms, the problem in question regards how data can be manipulated in order to establish a connection between the QActor facade and its virtual representation.
              More precisely, we can define two possible models. Please note that the following schemes are not the only possible options that can be considered, but they are just the result of my own personal reasoning.

              <br>
              <br>

              <div class="mdl-card__media content-card">
                <img src="img/modelA.png" border="0" alt="">
              </div>

              <div class="mdl-card__media content-card">
                <img src="img/modelB.png" border="0" alt="">
              </div>

              <br>

              Starting from the observation of <b>model A</b>, we can state the following aspects.

              <ul>
                <li>
                  The mapping load is all bestowed upon the QActor environment. Thus, once the simulation theory is defined, the net support
                  just sends the mapping result data to the Unity framework. However, even if the syntax used for describing the pieces of information
                  is prolog-like (generally speaking a string), there is still the necessity to parse the received data at Unity side. 
                </li>

                <li>
                  Generally speaking the only stage of the data flow manipulation process is the mapping phase. This is the case in which we define
                  a unique data format in order to do not affect the net support. More precisely, it is revelant to stress the fact that if we don't
                  choose a fixed way to exchange data between the two environments we have to take into account any sort of modifications to the net
                  communication layer. 
                </li>
              </ul>

              On the other hand, if we focus now on <b>model B</b> we can take the following considerations.

              <ul>
                <li>
                  The mapping load is all attributed to the Unity environment. As a result, once a proper mapping behaviour is defined, the engine can
                  work autonomously. Any business logic change directly affects the mapping stage only.
                </li>

                <li>
                  Since there is not any sort of data manipulation at QActor level, we can state that the data format is the same used by actors, that is
                  prolog terms. However, even though the QActor framework remains almost untouched, there is still the necessity to maintain a sort of alignment
                  between actors' theories and the data mapping at Unity side.
                </li>
              </ul>

              So, what's the most suitable for our problem? Well, the first thing that came up with my mind is if there was any sort of prolog plugin for Unity.
              In this case <b>model B</b> would be the best one since the mapping stage will be mainly composed by prolog theories.
              Likely, I was able to find a sort of swi-prolog like syntax interpreter that can also directly interact with Unity monobehaviours. The one I'm talking about is the <a class="noline" href="https://github.com/ianhorswill/UnityProlog" >Unity-Prolog project by Ian Horswill</a>.

              <h5> Unity Prolog </h5>

              The reason why I've decided to use a prolog interpreter at Unity side is because of the significant reduction of development time that it could
              cause. By doing so, the only remaining steps about data manipulation were the definition of prolog terms at QActor side, which would have matched with the Unity Prolog theories, and the Unity's specific scripts, responsible of the linking between the prolog layer and the final simulation rendering.
              However, the main negative aspect is that, since this is a open-source project, its continous and active support may not be guaranteed. Moreover, by choosing Unity Prolog, inevitably any developer that wants to use this project has to firstly take a look at its <a class="noline" href="https://github.com/ianhorswill/UnityProlog/tree/master/Documentation">documentation</a>.

              <h5> UniRx </h5>

              Another choice concerning data streams that I took is <a class="noline" href="https://github.com/neuecc/UniRx">UniRx</a>. Since the communication between the Unity and QActor's environments is based upon continous flows of data, why don't we use a Observer/Observable pattern? Probably, for those that are not in <a class="noline" href="http://reactivex.io/"> ReactiveX </a>, this may sound a bit masochistic, but after a relatively short amount of time you will definitely change your mind since it is very useful and it can ease your development process. Anyway, the main reason why I've decided to use this library is basically because of a pure educational purpose.

              </div>            
            </div>            
          </section>

          <!--STRUCTURE-->
          <section class="section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp" id="structure">
            <div class="mdl-card mdl-cell mdl-cell--12-col content-card-vision">
              <div class="mdl-card__supporting-text">
                <h4>Project Structure </h4>
                The Unity Actor Simulator project is graphically summed up via the following <b>UML</b> diagram.

                <br> <br>

                <div class="mdl-card__media content-card">
                  <img src="img/project.png" border="0" alt="">
                </div>

                <br> <br>

                As we can see, it is possible to distinguish the following packages.

                <h5 style="color:rgba(237,28,36,1.0)" id="net"> Net Package </h5>

                  The net package is responsible of the communication between the two environments, implemented via the <b>TCP</b> protocol.
                  Therefore, we can identify three main functionalities that define the main task that gives the name to this package.

                  <ul>
                    <li>
                      <b> TCP Server: </b> represented by the <b>TcpConnectorListener</b> class. Since we want to interact with the external environment, that is
                      QActors' one, it is necessary to setup a proper TCP server able to handle multiple client requests at the same time. More precisely, the C# class uses a <b>TcpListener</b> that is sensitive to incoming external requests. For each new connection established, the <b>TcpConnectorListener</b> creates a <b>TcpActorClientHandler</b> instance, responsible of handling the communication with the client in both directions. <br>
                      Lastly, the <b>TcpConnectorListener</b> derives from <b>MonoBehaviour</b>, which is a Unity's specific class. Thus, in order to properly use this class, you only need to add the script as a component to a <b>GameObject</b> in the scene.

                      <br> <br>

                      <div class="mdl-card__media content-card">
                        <img src="img/tcpconnectorlistener.png" border="0" alt="">
                      </div>

                      <br> <br>

                      <b>Note:</b> the <b>Clear Actor on Close</b> option, when enabled, allows to automatically remove the simulated actor's gameobject on connection interruption. This can be useful during test runs since it allows to establish multiple connections without worrying about the Unity side.                     

                    </li>

                    <br>

                    <li>
                      <b> Client Handler: </b> represented by the <b>TcpActorClientHandler</b> abstract class which defines the general behaviour of a client's handler. In particular, the net package defines its own default implementation of the client's handler, that is <b>TcpReactiveActorClientHandler</b>, which receives and sends data in a prolog-like syntax and exploits UniRx's functionalities. <br>
                      <b style="color:red">More precisely, it exploits the Unity Prolog library by trying to unify the received prolog goal within the loaded theories. Thus, if there isn't any loaded theory, nothing will be executed associated to that received command and the Unity Prolog interpreter will fail.</b>
                    </li>

                    <br>

                    <li>
                      <b> Configuration: </b> in order to do not define a fixed behaviour, the <b>TcpConnectorListener</b> gives the user the possibility
                      to modify its initialization process by reading a <b>Json</b> file. More precisely, it uses the utility class <b>JsonHelper</b> in order to read the custom configuration from a .json file and store it in a <b>NetSetupInfo</b> instance. The customizable properties are the following ones.
                        <ul>
                          <li>
                            IP Address
                          </li>
                          <li>
                            Port
                          </li>
                          <li>
                            Client's Handler
                          </li>
                        </ul>

                      <br>
                      <b>Note:</b> The <b>TcpConnectorListener</b> script automatically searches for its configuration file under the folder <i>Assets/Configuration</i>. <b style="color:red">Therefore, if you don't have one, remember to create it!</b>
                      <br> <br>

                    </li>

                    <li>
                      <b> MQTT: </b> The communication between the Unity environment and the external one can be done via the MQTT connectivity protocol. More precisely, the Unity Actor Simulator project introduces the <b>MqttClientComponent</b> which basically wraps up a <b>MqttClient</b> by exploiting the UniRx plugin. In particular, common events emitted by the <b>MqttClient</b> class (i.e. published, subscribed) can be viewed as <b>IObservables</b>. <br>
                      In order to properly use the <b>MqttClientComponent</b> class, since it derives from <b>MonoBehaviour</b>, the only step required is to add it as a <b>Component</b> to one of your <b>GameObjects</b>.

                      <br> <br>

                      <div class="mdl-card__media content-card">
                        <img src="img/mqtt.png" border="0" alt="">
                      </div>

                      <br> <br>

                      As you can see, the <b>MqttClientComponent</b> script exposes some public parameters.

                      <br> <br>

                      <ul>
                      <li>
                      	<b>Broker Host Name:</b> the MQTT server's IP address to which the client connects. More precisely, it is not necessary to specify the protocol used in the IP address, since this will cause an exception during the connection phase. For example, suppose you have <i>"tcp://m2m.eclipse.org:1883" as the IP address. The correct <i>Broker Host Name</i> value will be <i>"m2m.eclipse.org"</i>. The port number is standardized, in this way it is not necessary to specify it. 
                      </li>
                      <br>
                      <li>
                      	<b>Client ID:</b> the ID used by the <b>MqttClient</b> during the connection phase. This parameter is optional. This means that if nothing is specified, a new ID will be generated. The automatic ID generation is done via the <b>Guid</b> class.
                      </li>
                      <br>
                      <li>
                      	<b>Connect On Start:</b> if enabled, allows the <b>MqttClient</b> to connect on script's Start method.
                      </li>
                      <br>
                      <li>
                      	<b>Subscribe On Start:</b> if enabled, allows the <b>MqttClient</b> to subscribe to specified topics on script's Start method.
                      </li>
                      <br>
                      <li>
                      	<b>Topics:</b> topics to which you want to subscribe to.
                      </li>
                      </ul>

                    </li>

                  </ul>



                <h5 style="color:rgba(0,162,232,1.0)" id="actor"> Actor Package </h5>

                The actor package is very simple due to the fact that it defines the general structure of the actor's settings, which are always identified by its name. In other terms, each custom actor's set of properties is uniquely identified by the actor's name.
                It is important to underline that a class that derives from <b>BaseActorSettings</b> only defines the set of symbols and properties to which
                the simulated actor is sensitive to. Thus, in order to convert these pieces of information into something understandable by the Unity Engine, it is necessary to define a proper mapper class! 

                <br> <br>

                Moreover, the package includes the so called <b>UnityPrologUtility</b> class that, as the name says, offers some support functionalities directly invoked by prolog theories. So why then is this class inserted into this package? The <b>UnityPrologUtility</b> allows to create outgoing data in prolog syntax, in accordance with the QActors' communication semantics, that are <b>messages</b> and <b>events</b>. More precisely, it offers methods like <b><code>BuildEvent</code></b> and <b><code>BuildMessage</code></b>. In addition, regarding messages, the <b>MessageType</b> enum defines all the possible semantics that are currently supported by the QActors' framework.

                <br> <br>

                <b>Note:</b> In order to properly attach to QActors' communication semantics, the sending of data derived from <b>UnityPrologUtility</b> communication methods (the ones described above) is not enough since the functors used by the class are custom and therefore they require a further interpretation at QActors' side. However, there's no reason to worry about that, since the parsing process can be automatically handled by the <b>DefaultConnectorParser</b> class, used by the <b>UnityConnector</b> class. <br>
                All these classes belong to the <a class="noline" href="https://bitbucket.org/hl2exe/unity-actor-connector"> Unity Actor Connector </a> Java project that will be discussed in more detail in this section.

                <h5 style="color:rgba(34,177,76,0.99)" id="configuration"> Configuration Package </h5>

                The configuration package is composed by Json configuration files and the <b>SettingsDatabase</b> class. More precisely, at system's start, the latter loads the defined files and stores their contents in <b>SettingsSetupInfo</b> instances. The result of this process it to create a link between each actor and their specific configurations. In particular, it is revelant to underline that there exists three concepts.

                  <ul>
                    <li>
                      <b>Actor:</b> identified by its name which must be unique.
                    </li>

                    <li>
                      <b>Actor's Settings:</b> define the symbols and properties to which the actor is sensitive.
                    </li>

                    <li>
                      <b>Actor's Settings Mapper:</b> associates to each symbol an action that can be rendered by Unity.
                    </li>
                  </ul>

                In addition we distinguish two types of Json configuration files.

                  <ul> 
                   <li>
                   <b>Mapping settings:</b> this is the file that is stored by the <b>SettingsSetupInfo</b> class and which contains the following fields.
                    <ul>
                      <li>
                       Name of the Actor's setting Json file.
                      </li>

                      <li>
                       Name of Actor's settings wrapper type (the c# class).
                      </li>

                      <li>
                       Name of the settings wrapper's assembly.
                      </li>

                      <li>
                       Name of the Actor's setting mapper wrapper type (the c# class).
                      </li>

                      <li>
                       Name of the mapper wrapper's assembly.
                      </li>
                    </ul>
                   </li>

                   <br>

                   <li>
                   <b>Actor's setting:</b> this is the file that is stored by a custom class that derives from <b>BaseActorSettings</b>.
                   </li>

                  </ul>

                By doing these distinctions, we can now explain how each configuration is associated to its actor. First of all, the <b>SettingDatabase</b> loads
                the mapping settings files (you can define more than one if you want) and stores the result in a set of <b>SettingsSetupInfo</b> instances. Once done, it reads the actor's settings Json filename in each instance and proceeds loading those files. Lastly, for each loaded <b>BaseActorSettings</b>, the <b>SettingsDatabase</b> script associates a mapper (the one described in a mapping settings file) to the related actor's name by eliminating possible duplicates. This means that only one mapper can be associated to an actor! In other terms, at runtime, the relation's multiplicity between an actor and a mapper instance is 1:1.

                <br> <br>

                <div class="mdl-card__media content-card">
                  <img src="img/settingsdatabase.png" border="0" alt="">
                </div>

                <br> <br>


                <b>Note:</b> The <b>SettingsDatabase</b> class derives from <b>Monobehaviour</b> like <b>TcpConnectorListener</b>. Therefore, in order to use this script, you only need to add it as a component to a <b>GameObject</b>.

                <br> <br>

                <b>Note:</b> The <b>SettingsDatabase</b> script automatically searches for files that are under the folder <i>Assets/Configuration</i>. <b style="color:red">Therefore, if you don't have one, remember to create it!</b>  

                <h5 style="color:purple" id="utility"> Utility Package </h5>

                The utility package defines some various support functionalities that are described as follows.

                <ul>
                  <li>
                  <b>Singleton:</b> refers to <a class="noline" href="https://github.com/kleber-swf/Unity-Singleton-MonoBehaviour"> this </a> original script which I've simplified and adjusted in accordance with the Unity Editor's version on which this project is based. Briefly, it defines the concept of singleton for monobehaviours scripts, allowing them to "survive" even to scene changes. 
                  </li>

                  <li>
                  <b>JsonHelper:</b> refers to <a class="noline" href="http://stackoverflow.com/questions/36239705/serialize-and-deserialize-json-and-json-array-in-unity/36244111#36244111"> this </a> stackoverflows' post from which I've added some additional functionalities in order to work with files. 
                  </li>

                  <li>
                  <b>PrologConvertible:</b> very simple interface that just defines the <b>GetPrologRepresentation</b> method. This interface is used by <b>UnityPrologUtility</b>'s communication methods since the result is a string in prolog-like syntax.
                  </li>

                  <li>
                  <b>StringValueAttribute:</b> since enums can only have numerical values, it is not possible to directly specify a corresponding string value. Thus, regarding <b>MessageType</b> enum, this custom attribute allows to attach in the form of an annotation a string value to a enum value.
                  </li>

                  <li>
                  <b>ReflectionExtensionMethods:</b> very simple static class that just defines the <b>GetInheritedTypes</b> method. This extension method is used by the
                  <b>TcpConnectorListener</b> during the configuration step in order to verify if the client handler type's name, read from the Json file, derives from <b>TcpActorClientHandler</b>. 
                  </li>

                </ul>


              </div>              
            </div>            
          </section>

          <!-- INTERACTION -->
          <section class="section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp" id="interaction">
            <div class="mdl-card mdl-cell mdl-cell--12-col content-card-vision">
              <div class="mdl-card__supporting-text">
                <h4> Project Interaction </h4>

                In order to fully understand how an entity can be simulated via exploiting this project, it is useful to view the latter by the interactions point of view. More precisely, the below graph reports, step by step, the sequence of actions that are needed connect to the Unity simulation enviroment and to communicate with our simulated entity.

                <br> <br>

                <div class="mdl-card__media content-card">
                  <img src="img/interaction.png" border="0" alt="">
                </div>

                <br> <br>

                From the observation of the above graph, we can distinguish two different action sequences.

                <ul>
                  <li>
                    <b>External -> Unity</b>: this sequence of actions defines how an input, generated within the external environment, can arrive to the entity's simulated counterpart. In particular we can list the following actions.
                      <ul>
                      <li>
                        Connection request: net connection request to the <b>TcpConnectorListener</b> server.
                      </li>
                      <li>
                        Handler creation: by default it is a <b>TcpReactiveActorClientHandler</b> instance. 
                      </li>
                      <li>
                        Receiving data: the client's handler handles this step.
                      </li>
                      <li>
                        Consulting prolog theories: the incoming input data is parsed via prolog theories.
                      </li>
                      <li>
                        Notifying the simulated entity: within the prolog theories it is possible to access directly to <b>GameObjects</b> via procedure call. Moreover, by exploiting the <b>UnityPrologUtility</b> static class, it is possible to emit an event to which a component can be sensitive to. 
                      </li>
                      </ul>
                  </li>
                  <br>
                  <li>
                    <b>Unity -> External</b>: this sequence of actions describes how output data is generated withing the simulation environment and redirected to the external environment. Analogously, we can list the following actions.
                    <ul>
                    <li>
                      Accessing the client's handler: it is possible to have access to a specific client's handler via the <b>TcpConnectorListener</b> class.
                    </li>
                    <li>
                      <b>[Optional]</b> Building external environment compliant data: the <b>UnityPrologUtility</b> class gives an example of how it is possible to create events or messages in accordance to the QActor's specification.
                    </li>
                    <li>
                      Sending data: the client's handler handles this step.
                    </li>
                    </ul>
                  </li>
                </ul>


              </div>              
            </div>            
          </section>

          <!-- C# EVENTS -->
          <section class="section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp" id="events">
            <div class="mdl-card mdl-cell mdl-cell--12-col content-card-vision">
              <div class="mdl-card__supporting-text">
                <h4> In-depth Analysis: C# Events </h4>

                In this section, we report some pieces of the .NET documentation about C# events in order to clarify this concept since it exploited inside the Unity Actor Simulator project. The references are listed below. 

                <ul>
                <li>
                  <a href="https://msdn.microsoft.com/en-us/library/edzehd2t(v=vs.110).aspx"> https://msdn.microsoft.com/en-us/library/edzehd2t(v=vs.110).aspx </a>
                </li>
                <li>
                  <a href="https://www.intertech.com/Blog/c-sharp-tutorial-understanding-c-events/"> https://www.intertech.com/Blog/c-sharp-tutorial-understanding-c-events/ </a>
                </li>
                <li>
                  <a href="http://csharpindepth.com/Articles/Chapter2/Events.aspx"> http://csharpindepth.com/Articles/Chapter2/Events.aspx </a>
                </li>
                </ul>

                <h5> Events </h5>
                Events in the .NET Framework are based on the delegate model. The delegate model follows the observer design pattern, which enables a subscriber to register with, and receive notifications from, a provider. An event sender pushes a notification that an event has happened, and an event receiver receives that notification and defines a response to it. <br> <br>

                An event is a message sent by an object to signal the occurrence of an action. The action could be caused by user interaction, such as a button click, or it could be raised by some other program logic, such as changing a property’s value. The object that raises the event is called the event sender. The event sender doesn't know which object or method will receive (handle) the events it raises. The event is typically a member of the event sender <br> <br>

                Events are simple serial invocation. Thus, there is no any built-in parallelization or async of standard .NET events, it's up to you to implement it.

                <h5> Delegate </h5>

                A delegate is a type that holds a reference to a method. A delegate is declared with a signature that shows the return type and parameters for the methods it references, and can hold references only to methods that match its signature. A delegate is thus equivalent to a type-safe function pointer or a callback. A delegate declaration is sufficient to define a delegate class. Delegates have many uses in the .NET Framework. In the context of events, a delegate is an intermediary (or pointer-like mechanism) between the event source and the code that handles the event. You associate a delegate with an event by including the delegate type in the event declaration.

                <h5> Event Handlers </h5>

                The .NET Framework provides the <b>EventHandler</b> and <b>EventHandler&ltTEventArgs&gt</b> delegates to support most event scenarios. Use the <b>EventHandler</b> delegate for all events that do not include event data. Use the <b>EventHandler&ltTEventArgs&gt</b> delegate for events that include data about the event. These delegates have no return type value and take two parameters (an object for the source of the event and an object for event data). <br>
                Delegates are multicast, which means that they can hold references to more than one event-handling method. Delegates provide flexibility and fine-grained control in event handling. A delegate acts as an event dispatcher for the class that raises the event by maintaining a list of registered event handlers for the event.

                <h5> Event Data </h5>

                Data that is associated with an event can be provided through an event data class. The .NET Framework provides many event data classes that you can use in your applications. <br>

                The <b>EventArgs</b> class is the base type for all event data classes. <b>EventArgs</b> is also the class you use when an event does not have any data associated with it. When you create an event that is only meant to notify other classes that something happened and does not need to pass any data, include the <b>EventArgs</b> class as the second parameter in the delegate. You can pass the <b>EventArgs.Empty</b> value when no data is provided. The <b>EventHandler</b> delegate includes the <b>EventArgs</b> class as a parameter.
                When you want to create a customized event data class, create a class that derives from <b>EventArgs</b>, and then provide any members needed to pass data that is related to the event. Typically, you should use the same naming pattern as the .NET Framework and end your event data class name with <b>EventArgs</b>. <br>

              </div>              
            </div>            
          </section>

          <!-- MQTT -->
          <section class="section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp" id="mqtt">
            <div class="mdl-card mdl-cell mdl-cell--12-col content-card-vision">
              <div class="mdl-card__supporting-text">
                <h4> In-depth Analysis: MQTT Connectivity Protocol </h4>

                MQTT stands for MQ Telemetry Transport. It is a publish/subscribe, extremely simple and lightweight messaging protocol, designed for constrained devices and low-bandwidth, high-latency or unreliable networks. The design principles are to minimise network bandwidth and device resource requirements whilst also attempting to ensure reliability and some degree of assurance of delivery. These principles also turn out to make the protocol ideal of the emerging “machine-to-machine” (M2M) or “Internet of Things” world of connected devices, and for mobile applications where bandwidth and battery power are at a premium. <br>
                MQTT supports three different levels of Quality of Service (<b>QoS</b>).

                <br>
                <br>

                For more information about MQTT, please visit its <a class="noline" href="https://github.com/mqtt/mqtt.github.io/wiki"> documentation </a> page.

                <br>
                <br>

                For what concerns this project, the reference implementation is MQTT Paho, whose source code can be viewed <a class="noline" href="https://github.com/eclipse/paho.mqtt.m2mqtt"> here </a>. More precisely, in order to use the MQTT connectivity protocol, it is necessary to import the related dll file into your project's <b>Assets</b> folder.

              </div>              
            </div>            
          </section>

          <!-- UNIY ACTOR CONNECTOR -->
          <section class="section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp" id="unityconnector">
            <div class="mdl-card mdl-cell mdl-cell--12-col content-card-vision">
              <div class="mdl-card__supporting-text">
                <h4> In-depth Analysis: Unity Actor Connector </h4>

                This simple project has the role of intermediary between the QActors' environment and the simulation one, represented by Unity. Before viewing this project in more detail, please remember that, due to the fact that each environment is independent from the other one, it is necessary to introduce some sort of driver in order to establish a communication channel between them. <br>
                The whole project can be summarized by the following images.

                <br> <br>

                <div class="mdl-card__media content-card">
                  <img src="img/unityactorconnector.png" border="0" alt="">
                </div>

                <br> <br>

                <div class="mdl-card__media content-card">
                  <img src="img/unityactorconnector2.png" border="0" alt="">
                </div>

                <br> <br>

                As we can see, it is possible to distinguish the following packages.

                <h5 style="color:rgba(237,28,36,1.0)"> Net Package </h5>

                This package is simply composed by a default implementation of the <b>IConnector</b> interface, called <b>UnityConnector</b>. This basic TCP client is coded in order to send and read strings via UTF-8 encoding and decoding. Moreover, it allows encapsules some utility functions that are strictly associated with net client's handlers. In particular, in order to exploit these functionalities, like <b>setupActorSimulatorName</b> method, it is necessary to have a prolog theory file like <b>utilitytheory</b> or a proper parser at the remote side.

                <h5 style="color:rgba(0,162,232,1.0)"> Parsing Package </h5>

                This package is simply composed by a default implementation of the <b>IConnectorParser</b> interface, called <b>DefaultConnectorParser</b>. This basic class defines the <b>parseData</b> method that manages string data. More precisely, in order to attach to the QActors' environment, it is sensitive to possible events or messages. If the string to parse neither an event nor a message, the <b>DefaultConnectorParser</b> tries to interpret it as a prolog goal. In order to do so, the <b>DefaultConnectorParser</b> class has a reference to the QActor that is implementing the <b>ISimulated</b> interface.

                <h5 style="color:rgba(34,177,76,0.99)"> Actor Package </h5>

                This package is simply composed by the <b>ISimulated</b> interface which allows the QActor that implements it to access to a <b>IConnector</b> instance. More precisely, the interface defines only a <b>IConnector</b> property. By doing so, it is possible to inject a <b>IConnector</b> instance inside the QActor.

              </div>              
            </div>            
          </section>

          
        </div>

        <br>    

        <footer class="mdl-mega-footer">
          <div class="mdl-mega-footer--middle-section">
            <div class="mdl-mega-footer--drop-down-section">
              <input class="mdl-mega-footer--heading-checkbox" type="checkbox" checked>
              <h1 class="mdl-mega-footer--heading">Repos</h1>
              <ul class="mdl-mega-footer--link-list">
                <li><a class="mdl-navigation__link" href="https://bitbucket.org/hl2exe/">Bitbucket Repository</a></li>            
                <li><a class="mdl-navigation__link" href="https://github.com/federicoruggeri">GitHub Repository</a></li> 
              </ul>
            </div>
            <div class="mdl-mega-footer--drop-down-section">
              <input class="mdl-mega-footer--heading-checkbox" type="checkbox" checked>
              <h1 class="mdl-mega-footer--heading">Unity Actor Simulator</h1>
              <ul class="mdl-mega-footer--link-list">
                <li><a class="mdl-navigation__link" href="overview.html#intro">Intro</a></li>
                <li><a class="mdl-navigation__link" href="overview.html#install">Install</a></li> 
                <li><a class="mdl-navigation__link" href="overview.html#source">Source Code</a></li>  
                <li><a class="mdl-navigation__link" href="overview.html#vision">Vision</a></li>            
                <li><a class="mdl-navigation__link" href="overview.html#goal">Goals</a></li> 
                <li><a class="mdl-navigation__link" href="overview.html#requirements">Requirements</a></li> 
                <li><a class="mdl-navigation__link" href="analysis.html#requirements">Requirements Analysis</a></li> 
                <li><a class="mdl-navigation__link" href="analysis.html#problem">Problem Analysis</a></li> 
                <li><a class="mdl-navigation__link" href="project.html">Project</a></li> 
                <li><a class="mdl-navigation__link" href="install guide.html">Install Guide</a></li>
                <li><a class="mdl-navigation__link" href="examples.html">Examples</a></li>
              </ul>
            </div>
            <div class="mdl-mega-footer--drop-down-section">
              <input class="mdl-mega-footer--heading-checkbox" type="checkbox" checked>
              <h1 class="mdl-mega-footer--heading">Email</h1>
              <ul class="mdl-mega-footer--link-list">
                <li>federugg26@gmail.com</li>            
                <li>federico.ruggeri4@studio.unibo.it</li> 
              </ul>
            </div>           
          </div>
        </footer>

      </main>
    </div>

    <a href="analysis.html" id="prev" class="mdl-button mdl-js-button mdl-button--fab mdl-button--raised mdl-js-ripple-effect mdl-color--accent mdl-color-text--accent-contrast"><i class="material-icons">navigate_before</i></a>

    <a href="install guide.html" id="next" class="mdl-button mdl-js-button mdl-button--fab mdl-button--raised mdl-js-ripple-effect mdl-color--accent mdl-color-text--accent-contrast"><i class="material-icons">navigate_next</i></a>

    <script src="https://code.getmdl.io/1.3.0/material.min.js"></script>
  </body>
</html>
